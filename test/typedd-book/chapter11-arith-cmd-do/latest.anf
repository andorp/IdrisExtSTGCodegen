{__mainExpression:0} = []: %let v0 = (<{{__mainExpression:0}:0} underapp 1>()) in (PrimIO.unsafePerformIO(v0))
{{__mainExpression:0}:0} = [0]: Main.main(v0)
{csegen:6} = []: %let v0 = (<{{csegen:6}:0} underapp 5>()) in (%let v1 = (<{{csegen:6}:1} underapp 3>()) in (%let v2 = (<{{csegen:6}:2} underapp 5>()) in (%con Prelude.Interfaces.MkApplicative(v0, v1, v2))))
{{csegen:6}:2} = [4, 3, 2, 1, 0]: %let v5 = (v2 @ (v0)) in (%let v6 = (v1 @ (v0)) in (v5 @ (v6)))
{{csegen:6}:1} = [2, 1, 0]: v1
{{csegen:6}:0} = [4, 3, 2, 1, 0]: Prelude.IO.map(v2, v1, v0)
{csegen:9} = []: <{{csegen:9}:0} underapp 5>()
{{csegen:9}:0} = [4, 3, 2, 1, 0]: %let v5 = (v2 @ (v0)) in (%let v6 = (v1 @ (v5)) in (v6 @ (v0)))
{csegen:13} = []: %let v3 = (%let v0 = ({csegen:6}()) in (%let v1 = ({csegen:9}()) in (%let v2 = (<{{csegen:13}:0} underapp 3>()) in (%con Prelude.Interfaces.MkMonad(v0, v1, v2))))) in (%let v4 = (<{{csegen:13}:1} underapp 2>()) in (%con Prelude.IO.MkHasIO(v3, v4)))
{{csegen:13}:1} = [1, 0]: v0
{{csegen:13}:0} = [2, 1, 0]: %let v3 = (v1 @ (v0)) in (v3 @ (v0))
prim__add_Integer = [0, 1]: %op +Integer(v0, v1)
prim__sub_Integer = [0, 1]: %op -Integer(v0, v1)
prim__mul_Integer = [0, 1]: %op *Integer(v0, v1)
Main.with block in arithInputs,bound = [0, 1, 2]: %case v2 of { %conalt Data.Primitives.Views.IntV.DivBy(v3, v4, v5) => %let v6 = (Prelude.Num.abs(v4)) in (%let v7 = (1) in (%op +Int(v6, v7))) Nothing }
Main.4719:1440:bound = [0, 1]: %let v3 = (%let v2 = (12) in (Data.Primitives.Views.IntV.divides(v1, v2))) in (Main.with block in arithInputs,bound(v0, v1, v3))
Main.wrong = [0, 1, 2]: %let v8 = (%let v7 = (%let v5 = ("Wrong, the answer is ") in (%let v6 = (%let v3 = (Prelude.Show.show(v1)) in (%let v4 = ("\n") in (%op ++(v3, v4)))) in (%op ++(v5, v6)))) in (%con Main.PutStr(v7))) in (%let v9 = (<Main.{wrong:0} underapp 1>(v0, v2)) in (Main.ConsoleDo.>>(v8, v9)))
Main.{wrong:0} = [0, 1, 2]: Main.quiz(v0, v1)
Main.runCommand = [0]: %case v0 of { %conalt Main.PutStr(v1) => %let v2 = ({csegen:13}()) in (Prelude.IO.putStr(v2, v1))| %conalt Main.GetLine() => %let v3 = ({csegen:13}()) in (Prelude.IO.getLine(v3))| %conalt Main.Pure(v4) => <Main.{runCommand:0} underapp 1>(v4)| %conalt Main.Bind(v5, v6) => <Main.{runCommand:1} underapp 1>(v5, v6) Nothing }
Main.{runCommand:1} = [0, 1, 2]: %let v3 = (%let v4 = (Main.runCommand(v0)) in (v4 @ (v2))) in (%let v6 = (%let v5 = (v1 @ (v3)) in (Main.runCommand(v5))) in (v6 @ (v2)))
Main.{runCommand:0} = [0, 1]: v0
Main.run = [0, 1]: %case v1 of { %conalt Main.Quit(v2) => <Main.{run:0} underapp 1>(v2) Just %case v0 of { %conalt Main.More(v3) => %case v1 of { %conalt Main.Do(v4, v5) => <Main.{run:1} underapp 1>(v4, v5, v3)| %conalt Main.Seq(v6, v7) => %let v11 = (%let v8 = ({csegen:6}()) in (%let v9 = ({csegen:9}()) in (%let v10 = (<Main.{run:2} underapp 3>()) in (%con Prelude.Interfaces.MkMonad(v8, v9, v10))))) in (%let v12 = (Main.runCommand(v6)) in (%let v13 = (<Main.{run:3} underapp 1>(v7, v3)) in (Prelude.Interfaces.>>(v11, v12, v13)))) Nothing }| %conalt Main.Dry() => <Main.{run:4} underapp 1>() Nothing } }
Main.{run:4} = [0]: %con Prelude.Types.Nothing()
Main.{run:3} = [0, 1, 2]: %let v3 = (v1 @ ([__])) in (%let v4 = (v0 @ ([__])) in (Main.run(v3, v4)))
Main.{run:2} = [2, 1, 0]: %let v3 = (v1 @ (v0)) in (v3 @ (v0))
Main.{run:1} = [0, 1, 2, 3]: %let v4 = (%let v5 = (Main.runCommand(v0)) in (v5 @ (v3))) in (%let v9 = (%let v7 = (v2 @ ([__])) in (%let v8 = (%let v6 = (v1 @ (v4)) in (v6 @ ([__]))) in (Main.run(v7, v8)))) in (v9 @ (v3)))
Main.{run:0} = [0, 1]: %con Prelude.Types.Just(v0)
Main.readInput = [0]: %let v3 = (%con Main.PutStr(v0)) in (%let v4 = (%let v1 = (%con Main.GetLine()) in (%let v2 = (<Main.{readInput:0} underapp 1>()) in (Main.CommandDo.>>=(v1, v2)))) in (Main.CommandDo.>>(v3, v4)))
Main.{readInput:0} = [0]: %let v6 = (%let v1 = (Data.String.toLower(v0)) in (%let v2 = ("quit") in (Prelude.EqOrd.==(v1, v2)))) in (%case v6 of { %constalt(1) => %let v3 = (%con Main.QuitCmd()) in (%con Main.Pure(v3))| %constalt(0) => %let v5 = (%let v4 = (Prelude.Cast.cast(v0)) in (%con Main.Answer(v4))) in (%con Main.Pure(v5)) Nothing })
Main.randoms = [0]: %let v1 = (%let v5 = (%let v3 = (%let v2 = (1664525) in (%op cast-Integer-Int(v2))) in (%op *Int(v3, v0))) in (%let v6 = (%let v4 = (1013904223) in (%op cast-Integer-Int(v4))) in (%op +Int(v5, v6)))) in (%let v9 = (%let v8 = (%let v7 = (2) in (Prelude.Cast.cast(v7))) in (%op shr Int(v1, v8))) in (%let v10 = (<Main.{randoms:0} underapp 1>(v1)) in (%con Prelude.Types.Stream.::(v9, v10))))
Main.{randoms:0} = [0, 1]: Main.randoms(v0)
Main.quiz = [0, 1]: %case v0 of { %conalt Prelude.Types.Stream.::(v2, v3) => %let v4 = (v3 @ ([__])) in (%case v4 of { %conalt Prelude.Types.Stream.::(v5, v6) => %let v12 = (%let v11 = (%let v9 = ("Score so far: ") in (%let v10 = (%let v7 = (Prelude.Show.show(v1)) in (%let v8 = ("\n") in (%op ++(v7, v8)))) in (%op ++(v9, v10)))) in (%con Main.PutStr(v11))) in (%let v13 = (<Main.{quiz:4} underapp 1>(v5, v6, v2, v1)) in (Main.ConsoleDo.>>(v12, v13))) Nothing }) Nothing }
Main.{quiz:4} = [0, 1, 2, 3, 4]: %let v12 = (%let v11 = (%let v9 = (Prelude.Show.show(v2)) in (%let v10 = (%let v7 = (" * ") in (%let v8 = (%let v5 = (Prelude.Show.show(v0)) in (%let v6 = ("? ") in (%op ++(v5, v6)))) in (%op ++(v7, v8)))) in (%op ++(v9, v10)))) in (Main.readInput(v11))) in (%let v13 = (<Main.{quiz:3} underapp 1>(v0, v1, v2, v3)) in (Main.ConsoleDo.>>=(v12, v13)))
Main.{quiz:3} = [0, 1, 2, 3, 4]: %case v4 of { %conalt Main.Answer(v5) => %let v7 = (%let v6 = (%op *Int(v2, v0)) in (Prelude.EqOrd.==(v5, v6))) in (%case v7 of { %constalt(1) => <Main.{quiz:0} underapp 1>(v1, v3)| %constalt(0) => <Main.{quiz:1} underapp 1>(v0, v1, v2, v3) Nothing })| %conalt Main.QuitCmd() => <Main.{quiz:2} underapp 1>(v3) Nothing }
Main.{quiz:2} = [0, 1]: %con Main.Quit(v0)
Main.{quiz:1} = [0, 1, 2, 3, 4]: %let v5 = (v1 @ ([__])) in (%let v6 = (%op *Int(v2, v0)) in (Main.wrong(v5, v6, v3)))
Main.{quiz:0} = [0, 1, 2]: %let v3 = (v0 @ ([__])) in (Main.correct(v3, v1))
Main.main = [0]: %let v1 = (%let v3 = (%let v2 = ({csegen:13}()) in (System.time(v2))) in (v3 @ (v0))) in (%let v4 = (%let v11 = (%let v9 = (Main.forever()) in (%let v10 = (%let v7 = (%let v6 = (%let v5 = (0) in (%op cast-Integer-Int(v5))) in (Main.arithInputs(v6))) in (%let v8 = (0) in (Main.quiz(v7, v8)))) in (Main.run(v9, v10)))) in (v11 @ (v0))) in (%case v4 of { %conalt Prelude.Types.Just(v12) => %let v17 = (%let v15 = ({csegen:13}()) in (%let v16 = (%let v13 = ("Final score: ") in (%let v14 = (Prelude.Show.show(v12)) in (%op ++(v13, v14)))) in (Prelude.IO.putStrLn(v15, v16)))) in (v17 @ (v0))| %conalt Prelude.Types.Nothing() => %let v20 = (%let v18 = ({csegen:13}()) in (%let v19 = ("Ran out of fuel") in (Prelude.IO.putStrLn(v18, v19)))) in (v20 @ (v0)) Nothing }))
Main.forever = []: %let v0 = (<Main.{forever:0} underapp 1>()) in (%con Main.More(v0))
Main.{forever:0} = [0]: Main.forever()
Main.correct = [0, 1]: %let v3 = (%let v2 = ("Correct!\n") in (%con Main.PutStr(v2))) in (%let v4 = (<Main.{correct:0} underapp 1>(v0, v1)) in (Main.ConsoleDo.>>(v3, v4)))
Main.{correct:0} = [0, 1, 2]: %let v4 = (%let v3 = (1) in (%op +Integer(v1, v3))) in (Main.quiz(v0, v4))
Main.arithInputs = [0]: %let v1 = (<Main.{arithInputs:0} underapp 1>(v0)) in (%let v2 = (Main.randoms(v0)) in (Prelude.Types.map(v1, v2)))
Main.{arithInputs:0} = [0, 1]: Main.4719:1440:bound(v0, v1)
Main.Seq = Constructor tag Just 2 arity 2 newtype by Nothing
Main.QuitCmd = Constructor tag Just 1 arity 0 newtype by Nothing
Main.Quit = Constructor tag Just 0 arity 1 newtype by Nothing
Main.PutStr = Constructor tag Just 0 arity 1 newtype by Nothing
Main.Pure = Constructor tag Just 2 arity 1 newtype by Nothing
Main.More = Constructor tag Just 1 arity 1 newtype by Nothing
Main.GetLine = Constructor tag Just 1 arity 0 newtype by Nothing
Main.Do = Constructor tag Just 1 arity 2 newtype by Nothing
Main.Bind = Constructor tag Just 3 arity 2 newtype by Nothing
Main.Answer = Constructor tag Just 0 arity 1 newtype by Nothing
Main.ConsoleDo.>>= = [0, 1]: %con Main.Do(v0, v1)
Main.CommandDo.>>= = [0, 1]: %con Main.Bind(v0, v1)
Main.ConsoleDo.>> = [0, 1]: %con Main.Seq(v0, v1)
Main.CommandDo.>> = [0, 1]: %let v2 = (<Main.CommandDo.{>>:0} underapp 1>(v1)) in (%con Main.Bind(v0, v2))
Main.CommandDo.{>>:0} = [0, 1]: v0
System.time = [0]: %case v0 of { %conalt Prelude.IO.MkHasIO(v1, v2) => %case v1 of { %conalt Prelude.Interfaces.MkMonad(v3, v4, v5) => %let v13 = (%let v11 = (%let v6 = (v4 @ ([__])) in (v6 @ ([__]))) in (%let v12 = (%case v0 of { %conalt Prelude.IO.MkHasIO(v7, v8) => %let v9 = (v8 @ ([__])) in (%let v10 = (<System.{time:0} underapp 1>()) in (v9 @ (v10))) Nothing }) in (v11 @ (v12)))) in (%let v14 = (<System.{time:1} underapp 1>(v0)) in (v13 @ (v14))) Nothing } Nothing }
System.{time:1} = [0, 1]: %case v0 of { %conalt Prelude.IO.MkHasIO(v2, v3) => %case v2 of { %conalt Prelude.Interfaces.MkMonad(v4, v5, v6) => %case v4 of { %conalt Prelude.Interfaces.MkApplicative(v7, v8, v9) => %let v10 = (v8 @ ([__])) in (%let v11 = (Prelude.Cast.cast(v1)) in (v10 @ (v11))) Nothing } Nothing } Nothing }
System.{time:0} = [0]: System.prim__time(v0)
System.prim__time = Foreign call ["C:idris2_time, libidris2_support, idris_support.h", "javascript:lambda:() => Math.floor(new Date().getTime() / 1000)"] [%World] -> IORes Int
Prelude.Basics.Nil = Constructor tag Just 0 arity 0 newtype by Nothing
Prelude.Basics.:: = Constructor tag Just 1 arity 2 newtype by Nothing
Builtin.idris_crash = [0]: %op crash([__], v0)
Builtin.believe_me = [0]: %op believe_me([__], [__], v0)
Builtin.Refl = Constructor tag Just 0 arity 0 newtype by Nothing
Prelude.Types.map = [0, 1]: %case v1 of { %conalt Prelude.Types.Stream.::(v2, v3) => %let v4 = (v0 @ (v2)) in (%let v5 = (<Prelude.Types.{map_Functor_Stream:0} underapp 1>(v3, v0)) in (%con Prelude.Types.Stream.::(v4, v5))) Nothing }
Prelude.Types.{map_Functor_Stream:0} = [0, 1, 2]: %let v3 = (v0 @ ([__])) in (Prelude.Types.map(v1, v3))
Prelude.Types.map = [0, 1]: %case v1 of { %conalt Prelude.Basics.Nil() => %con Prelude.Basics.Nil()| %conalt Prelude.Basics.::(v2, v3) => %let v4 = (v0 @ (v2)) in (%let v5 = (Prelude.Types.map(v0, v3)) in (%con Prelude.Basics.::(v4, v5))) Nothing }
Prelude.Types.toLower = [0]: %let v4 = (Prelude.Types.isUpper(v0)) in (%case v4 of { %constalt(1) => %let v3 = (%let v1 = (%op cast-Char-Int(v0)) in (%let v2 = (32) in (%op +Int(v1, v2)))) in (%op cast-Int-Char(v3))| %constalt(0) => v0 Nothing })
Prelude.Types.prim__integerToNat = [0]: %let v3 = (%let v2 = (%let v1 = (0) in (%op <=Integer(v1, v0))) in (%case v2 of { %constalt(0) => 0 Just 1 })) in (%case v3 of { %constalt(1) => Builtin.believe_me(v0)| %constalt(0) => 0 Nothing })
Prelude.Types.isUpper = [0]: %let v3 = (%let v1 = ('A') in (Prelude.EqOrd.>=(v0, v1))) in (%case v3 of { %constalt(1) => %let v2 = ('Z') in (Prelude.EqOrd.<=(v0, v2))| %constalt(0) => 0 Nothing })
Prelude.Types.fastUnpack = Foreign call ["scheme:string-unpack", "RefC:fastUnpack", "javascript:lambda:(str)=>__prim_js2idris_array(Array.from(str))"] [String] -> Prelude.Basics.List Char
Prelude.Types.fastPack = Foreign call ["scheme:string-pack", "RefC:fastPack", "javascript:lambda:(xs)=>__prim_idris2js_array(xs).join('')"] [Prelude.Basics.List Char] -> String
Prelude.Types.Nothing = Constructor tag Just 0 arity 0 newtype by Nothing
Prelude.Types.Just = Constructor tag Just 1 arity 1 newtype by Nothing
Prelude.Types.Stream.:: = Constructor tag Just 0 arity 2 newtype by Nothing
Prelude.Num.div = [0, 1]: %let v6 = (%let v3 = (%let v2 = (0) in (%op cast-Integer-Int(v2))) in (Prelude.EqOrd.==(v1, v3))) in (%case v6 of { %constalt(0) => %op /Int(v0, v1) Just %let v4 = (Builtin.idris_crash([__])) in (%let v5 = ("Unhandled input for Prelude.Num.case block in div at Prelude.Num:128:3--130:40") in (v4 @ (v5))) })
Prelude.Num.abs = [0]: %let v4 = (%let v2 = (%let v1 = (0) in (%op cast-Integer-Int(v1))) in (Prelude.EqOrd.<(v0, v2))) in (%case v4 of { %constalt(1) => %let v3 = (0) in (%op -Int(v3, v0))| %constalt(0) => v0 Nothing })
Prelude.EqOrd.compare = [0, 1]: %let v3 = (Prelude.EqOrd.<(v0, v1)) in (%case v3 of { %constalt(1) => 0| %constalt(0) => %let v2 = (Prelude.EqOrd.==(v0, v1)) in (%case v2 of { %constalt(1) => 1| %constalt(0) => 2 Nothing }) Nothing })
Prelude.EqOrd.>= = [0, 1]: %let v2 = (%op >=Char(v0, v1)) in (%case v2 of { %constalt(0) => 0 Just 1 })
Prelude.EqOrd.== = [0, 1]: %let v2 = (%op ==String(v0, v1)) in (%case v2 of { %constalt(0) => 0 Just 1 })
Prelude.EqOrd.== = [0, 1]: %case v0 of { %constalt(0) => %case v1 of { %constalt(0) => 1 Just 0 }| %constalt(1) => %case v1 of { %constalt(1) => 1 Just 0 }| %constalt(2) => %case v1 of { %constalt(2) => 1 Just 0 } Just 0 }
Prelude.EqOrd.== = [0, 1]: %let v2 = (%op ==Integer(v0, v1)) in (%case v2 of { %constalt(0) => 0 Just 1 })
Prelude.EqOrd.== = [0, 1]: %let v2 = (%op ==Int(v0, v1)) in (%case v2 of { %constalt(0) => 0 Just 1 })
Prelude.EqOrd.== = [0, 1]: %let v2 = (%op ==Char(v0, v1)) in (%case v2 of { %constalt(0) => 0 Just 1 })
Prelude.EqOrd.< = [0, 1]: %let v2 = (%op <Integer(v0, v1)) in (%case v2 of { %constalt(0) => 0 Just 1 })
Prelude.EqOrd.< = [0, 1]: %let v2 = (%op <Int(v0, v1)) in (%case v2 of { %constalt(0) => 0 Just 1 })
Prelude.EqOrd.<= = [0, 1]: %let v2 = (%op <=Char(v0, v1)) in (%case v2 of { %constalt(0) => 0 Just 1 })
Prelude.EqOrd./= = [0, 1]: %let v2 = (Prelude.EqOrd.==(v0, v1)) in (%case v2 of { %constalt(1) => 0| %constalt(0) => 1 Nothing })
Prelude.Interfaces.MkMonad = Constructor tag Just 0 arity 3 newtype by Nothing
Prelude.Interfaces.MkApplicative = Constructor tag Just 0 arity 3 newtype by Nothing
Prelude.Interfaces.>> = [0, 1, 2]: %case v0 of { %conalt Prelude.Interfaces.MkMonad(v3, v4, v5) => %let v8 = (%let v7 = (%let v6 = (v4 @ ([__])) in (v6 @ ([__]))) in (v7 @ (v1))) in (%let v9 = (<Prelude.Interfaces.{>>:0} underapp 1>(v2)) in (v8 @ (v9))) Nothing }
Prelude.Interfaces.{>>:0} = [0, 1]: v0 @ ([__])
Prelude.Show.show = [0]: Prelude.Show.show(v0)
Prelude.Show.show = [0]: %let v1 = (%con Prelude.Show.Open()) in (Prelude.Show.showPrec(v1, v0))
Prelude.Show.show = [0]: %let v1 = (%con Prelude.Show.Open()) in (Prelude.Show.showPrec(v1, v0))
Prelude.Show.showPrec = [0, 1]: %let v2 = (<Prelude.Show.{showPrec_Show_Integer:0} underapp 1>()) in (Prelude.Show.primNumShow(v2, v0, v1))
Prelude.Show.{showPrec_Show_Integer:0} = [0]: %op cast-Integer-String(v0)
Prelude.Show.showPrec = [0, 1]: %let v2 = (<Prelude.Show.{showPrec_Show_Int:0} underapp 1>()) in (Prelude.Show.primNumShow(v2, v0, v1))
Prelude.Show.{showPrec_Show_Int:0} = [0]: %op cast-Int-String(v0)
Prelude.Show.compare = [0, 1]: %case v0 of { %conalt Prelude.Show.User(v2) => %case v1 of { %conalt Prelude.Show.User(v3) => Prelude.EqOrd.compare(v2, v3) Just %let v4 = (Prelude.Show.precCon(v0)) in (%let v5 = (Prelude.Show.precCon(v1)) in (Prelude.EqOrd.compare(v4, v5))) } Just %let v6 = (Prelude.Show.precCon(v0)) in (%let v7 = (Prelude.Show.precCon(v1)) in (Prelude.EqOrd.compare(v6, v7))) }
Prelude.Show.>= = [0, 1]: %let v2 = (Prelude.Show.compare(v0, v1)) in (%let v3 = (0) in (Prelude.EqOrd./=(v2, v3)))
Prelude.Show.showParens = [0, 1]: %case v0 of { %constalt(0) => v1| %constalt(1) => %let v3 = ("(") in (%let v4 = (%let v2 = (")") in (%op ++(v1, v2))) in (%op ++(v3, v4))) Nothing }
Prelude.Show.primNumShow = [0, 1, 2]: %let v3 = (v0 @ (v2)) in (%let v7 = (%let v6 = (%let v4 = (%con Prelude.Show.PrefixMinus()) in (Prelude.Show.>=(v1, v4))) in (%case v6 of { %constalt(1) => %let v5 = (<Prelude.Show.{primNumShow:0} underapp 1>()) in (Prelude.Show.firstCharIs(v5, v3))| %constalt(0) => 0 Nothing })) in (Prelude.Show.showParens(v7, v3)))
Prelude.Show.{primNumShow:0} = [0]: %let v1 = ('-') in (Prelude.EqOrd.==(v0, v1))
Prelude.Show.precCon = [0]: %case v0 of { %conalt Prelude.Show.Open() => 0| %conalt Prelude.Show.Equal() => 1| %conalt Prelude.Show.Dollar() => 2| %conalt Prelude.Show.Backtick() => 3| %conalt Prelude.Show.User(v1) => 4| %conalt Prelude.Show.PrefixMinus() => 5| %conalt Prelude.Show.App() => 6 Nothing }
Prelude.Show.firstCharIs = [0, 1]: %case v1 of { %constalt("") => 0 Just %let v2 = (%op op_strhead(v1)) in (v0 @ (v2)) }
Prelude.Show.PrefixMinus = Constructor tag Just 5 arity 0 newtype by Nothing
Prelude.Show.Open = Constructor tag Just 0 arity 0 newtype by Nothing
Prelude.IO.map = [0, 1, 2]: %let v3 = (v1 @ (v2)) in (v0 @ (v3))
Prelude.IO.putStrLn = [0, 1]: %let v3 = (%let v2 = ("\n") in (%op ++(v1, v2))) in (Prelude.IO.putStr(v0, v3))
Prelude.IO.putStr = [0, 1]: %case v0 of { %conalt Prelude.IO.MkHasIO(v2, v3) => %let v4 = (v3 @ ([__])) in (%let v5 = (<Prelude.IO.{putStr:0} underapp 1>(v1)) in (v4 @ (v5))) Nothing }
Prelude.IO.{putStr:0} = [0, 1]: Prelude.IO.prim__putStr(v0, v1)
Prelude.IO.prim__putStr = Foreign call ["C:idris2_putStr, libidris2_support, idris_support.h", "node:lambda:x=>process.stdout.write(x)", "browser:lambda:x=>console.log(x)"] [String, %World] -> IORes Unit
Prelude.IO.prim__getStr = Foreign call ["C:idris2_getStr, libidris2_support, idris_support.h", "node:support:getStr,support_system_file"] [%World] -> IORes String
Prelude.IO.getLine = [0]: %case v0 of { %conalt Prelude.IO.MkHasIO(v1, v2) => %let v3 = (v2 @ ([__])) in (%let v4 = (<Prelude.IO.{getLine:0} underapp 1>()) in (v3 @ (v4))) Nothing }
Prelude.IO.{getLine:0} = [0]: Prelude.IO.prim__getStr(v0)
Prelude.IO.MkHasIO = Constructor tag Just 0 arity 2 newtype by Nothing
PrimIO.unsafePerformIO = [0]: %let v1 = (<PrimIO.{unsafePerformIO:0} underapp 1>(v0)) in (PrimIO.unsafeCreateWorld(v1))
PrimIO.{unsafePerformIO:0} = [0, 1]: v0 @ (v1)
PrimIO.unsafeCreateWorld = [0]: %let v1 = (%MkWorld) in (v0 @ (v1))
Prelude.Cast.cast = [0]: %op cast-String-Int(v0)
Prelude.Cast.cast = [0]: %op cast-Integer-Int(v0)
Prelude.Cast.cast = [0]: %op cast-Int-Integer(v0)
Data.String.toLower = [0]: %let v3 = (%let v1 = (<Data.String.{toLower:0} underapp 1>()) in (%let v2 = (Prelude.Types.fastUnpack(v0)) in (Prelude.Types.map(v1, v2)))) in (Prelude.Types.fastPack(v3))
Data.String.{toLower:0} = [0]: Prelude.Types.toLower(v0)
Data.Primitives.Views.IntV.divides = [0, 1]: %case v1 of { %constalt(0) => %con Data.Primitives.Views.IntV.DivByZero() Just %let v2 = (%let v8 = (%let v4 = (%let v3 = (0) in (%op cast-Integer-Int(v3))) in (Prelude.EqOrd.<(v1, v4))) in (%case v8 of { %constalt(1) => %let v6 = (0) in (%let v7 = (%let v5 = (Prelude.Num.abs(v1)) in (Prelude.Num.div(v0, v5))) in (%op -Int(v6, v7)))| %constalt(0) => Prelude.Num.div(v0, v1) Nothing })) in (%let v9 = (%let v11 = (%let v10 = (%op *Int(v2, v1)) in (%op -Int(v0, v10))) in (Prelude.Num.abs(v11))) in (%let v14 = (%let v13 = (%let v12 = (%con Builtin.Refl()) in (Builtin.believe_me(v12))) in (%con Data.Primitives.Views.IntV.DivBy(v2, v9, v13))) in (Builtin.believe_me(v14)))) }
Data.Primitives.Views.IntV.DivByZero = Constructor tag Just 0 arity 0 newtype by Nothing
Data.Primitives.Views.IntV.DivBy = Constructor tag Just 1 arity 3 newtype by Nothing
