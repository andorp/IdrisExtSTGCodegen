{__mainExpression:0} = []: %let v0 = (Main.main()) in (PrimIO.unsafePerformIO(v0))
prim__add_Integer = [0, 1]: %op +Integer(v0, v1)
prim__sub_Integer = [0, 1]: %op -Integer(v0, v1)
prim__mul_Integer = [0, 1]: %op *Integer(v0, v1)
Main.case block in processInput = [0, 1, 2]: %case v2 of { %conalt Prelude.Types.Nothing() => %let v4 = (%let v3 = ("Invalid command\n") in (%con Builtin.MkPair(v3, v1))) in (%con Prelude.Types.Just(v4))| %conalt Prelude.Types.Just(v5) => %case v5 of { %conalt Main.Add(v6) => %let v17 = (%let v15 = (%let v13 = ("ID ") in (%let v14 = (%let v11 = (%let v10 = (%case v1 of { %conalt Main.MkData(v7, v8, v9) => v8 Nothing }) in (Prelude.Show.show(v10))) in (%let v12 = ("\n") in (%op ++(v11, v12)))) in (%op ++(v13, v14)))) in (%let v16 = (Main.addToStore(v1, v6)) in (%con Builtin.MkPair(v15, v16)))) in (%con Prelude.Types.Just(v17))| %conalt Main.SetSchema(v18) => %let v24 = (Main.setSchema(v1, v18)) in (%case v24 of { %conalt Prelude.Types.Nothing() => %let v20 = (%let v19 = ("Can't update schema when entries in store\n") in (%con Builtin.MkPair(v19, v1))) in (%con Prelude.Types.Just(v20))| %conalt Prelude.Types.Just(v21) => %let v23 = (%let v22 = ("OK\n") in (%con Builtin.MkPair(v22, v21))) in (%con Prelude.Types.Just(v23)) Nothing })| %conalt Main.Get(v25) => Main.getEntry(v25, v1)| %conalt Main.Quit() => %con Prelude.Types.Nothing() Nothing } Nothing }
Main.case block in parsePrefix = [0, 1, 2, 3]: %case v3 of { %conalt Prelude.Types.Nothing() => %con Prelude.Types.Nothing()| %conalt Prelude.Types.Just(v4) => %case v4 of { %conalt Builtin.MkPair(v5, v6) => %let v12 = (Main.parsePrefix(v0, v6)) in (%case v12 of { %conalt Prelude.Types.Nothing() => %con Prelude.Types.Nothing()| %conalt Prelude.Types.Just(v7) => %case v7 of { %conalt Builtin.MkPair(v8, v9) => %let v11 = (%let v10 = (%con Builtin.MkPair(v5, v8)) in (%con Builtin.MkPair(v10, v9))) in (%con Prelude.Types.Just(v11)) Nothing } Nothing }) Nothing } Nothing }
Main.case block in parsePrefix = [0, 1]: %case v1 of { %conalt Builtin.MkPair(v2, v3) => %case v2 of { %constalt("") => %con Prelude.Types.Nothing() Just %let v6 = (%let v4 = (Prelude.Cast.cast(v2)) in (%let v5 = (Data.String.ltrim(v3)) in (%con Builtin.MkPair(v4, v5)))) in (%con Prelude.Types.Just(v6)) } Nothing }
Main.4509:5173:getQuoted = [0, 1]: %case v1 of { %conalt Prelude.Basics.::(v2, v3) => %case v2 of { %constalt('"') => %let v13 = (%let v4 = (<Main.{4509:5173:getQuoted:0} underapp 1>()) in (Data.List.span(v4, v3))) in (%case v13 of { %conalt Builtin.MkPair(v5, v6) => %case v6 of { %conalt Prelude.Basics.::(v7, v8) => %case v7 of { %constalt('"') => %let v12 = (%let v10 = (Prelude.Types.fastPack(v5)) in (%let v11 = (%let v9 = (Prelude.Types.fastPack(v8)) in (Data.String.ltrim(v9))) in (%con Builtin.MkPair(v10, v11)))) in (%con Prelude.Types.Just(v12)) Just %con Prelude.Types.Nothing() } Just %con Prelude.Types.Nothing() } Just %con Prelude.Types.Nothing() }) Just %con Prelude.Types.Nothing() } Just %con Prelude.Types.Nothing() }
Main.{4509:5173:getQuoted:0} = [0]: %let v1 = ('"') in (Prelude.EqOrd./=(v0, v1))
Main.4408:5086:addToData = [0, 1, 2, 3, 4]: %case v4 of { %conalt Data.Vect.Nil() => %let v5 = (%con Data.Vect.Nil()) in (%con Data.Vect.::(v3, v5))| %conalt Data.Vect.::(v6, v7) => %let v8 = (Main.4408:5086:addToData(v0, v1, v2, v3, v7)) in (%con Data.Vect.::(v6, v8)) Nothing }
Main.setSchema = [0, 1]: %let v8 = (%case v0 of { %conalt Main.MkData(v2, v3, v4) => v3 Nothing }) in (%case v8 of { %constalt(0) => %let v7 = (%let v5 = (0) in (%let v6 = (%con Data.Vect.Nil()) in (%con Main.MkData(v1, v5, v6)))) in (%con Prelude.Types.Just(v7)) Just %con Prelude.Types.Nothing() })
Main.processInput = [0, 1]: %let v6 = (%let v5 = (%case v0 of { %conalt Main.MkData(v2, v3, v4) => v2 Nothing }) in (Main.parse(v5, v1))) in (Main.case block in processInput(v1, v0, v6))
Main.parseSchema = [0]: %case v0 of { %conalt Prelude.Basics.::(v1, v2) => %case v1 of { %constalt("String") => %case v2 of { %conalt Prelude.Basics.Nil() => %let v3 = (%con Main.SString()) in (%con Prelude.Types.Just(v3)) Just %let v7 = (Main.parseSchema(v2)) in (%case v7 of { %conalt Prelude.Types.Nothing() => %con Prelude.Types.Nothing()| %conalt Prelude.Types.Just(v4) => %let v6 = (%let v5 = (%con Main.SString()) in (%con Main..+.(v5, v4))) in (%con Prelude.Types.Just(v6)) Nothing }) }| %constalt("Int") => %case v2 of { %conalt Prelude.Basics.Nil() => %let v8 = (%con Main.SInt()) in (%con Prelude.Types.Just(v8)) Just %let v12 = (Main.parseSchema(v2)) in (%case v12 of { %conalt Prelude.Types.Nothing() => %con Prelude.Types.Nothing()| %conalt Prelude.Types.Just(v9) => %let v11 = (%let v10 = (%con Main.SInt()) in (%con Main..+.(v10, v9))) in (%con Prelude.Types.Just(v11)) Nothing }) } Just %con Prelude.Types.Nothing() } Just %con Prelude.Types.Nothing() }
Main.parsePrefix = [0, 1]: %case v0 of { %conalt Main.SString() => %let v2 = (Prelude.Types.fastUnpack(v1)) in (Main.4509:5173:getQuoted(v1, v2))| %conalt Main.SInt() => %let v4 = (%let v3 = (<Main.{parsePrefix:0} underapp 1>()) in (Data.String.span(v3, v1))) in (Main.case block in parsePrefix(v1, v4))| %conalt Main..+.(v5, v6) => %let v7 = (Main.parsePrefix(v5, v1)) in (Main.case block in parsePrefix(v6, v5, v1, v7)) Nothing }
Main.{parsePrefix:0} = [0]: Prelude.Types.isDigit(v0)
Main.parseCommand = [0, 1, 2]: %case v1 of { %constalt("add") => %let v5 = (Main.parseBySchema(v0, v2)) in (%case v5 of { %conalt Prelude.Types.Nothing() => %con Prelude.Types.Nothing()| %conalt Prelude.Types.Just(v3) => %let v4 = (%con Main.Add(v3)) in (%con Prelude.Types.Just(v4)) Nothing })| %constalt("get") => %let v17 = (%let v12 = (%let v6 = (<Main.{parseCommand:0} underapp 5>()) in (%let v7 = (<Main.{parseCommand:1} underapp 5>()) in (%let v8 = (<Main.{parseCommand:2} underapp 2>()) in (%let v9 = (<Main.{parseCommand:3} underapp 7>()) in (%let v10 = (<Main.{parseCommand:4} underapp 2>()) in (%let v11 = (<Main.{parseCommand:5} underapp 5>()) in (%con Prelude.Interfaces.MkFoldable(v6, v7, v8, v9, v10, v11)))))))) in (%let v13 = (<Main.{parseCommand:6} underapp 1>()) in (%let v14 = (Prelude.Types.fastUnpack(v2)) in (Prelude.Interfaces.all(v12, v13, v14))))) in (%case v17 of { %constalt(0) => %con Prelude.Types.Nothing()| %constalt(1) => %let v16 = (%let v15 = (Prelude.Cast.cast(v2)) in (%con Main.Get(v15))) in (%con Prelude.Types.Just(v16)) Nothing })| %constalt("quit") => %case v2 of { %constalt("") => %let v18 = (%con Main.Quit()) in (%con Prelude.Types.Just(v18)) Just %con Prelude.Types.Nothing() }| %constalt("schema") => %let v22 = (%let v19 = (Data.String.words(v2)) in (Main.parseSchema(v19))) in (%case v22 of { %conalt Prelude.Types.Nothing() => %con Prelude.Types.Nothing()| %conalt Prelude.Types.Just(v20) => %let v21 = (%con Main.SetSchema(v20)) in (%con Prelude.Types.Just(v21)) Nothing }) Just %con Prelude.Types.Nothing() }
Main.{parseCommand:6} = [0]: Prelude.Types.isDigit(v0)
Main.{parseCommand:5} = [4, 3, 2, 1, 0]: Prelude.Types.foldMap(v2, v1, v0)
Main.{parseCommand:4} = [1, 0]: v0
Main.{parseCommand:3} = [6, 5, 4, 3, 2, 1, 0]: Prelude.Types.foldlM(v3, v2, v1, v0)
Main.{parseCommand:2} = [1, 0]: Prelude.Types.null(v0)
Main.{parseCommand:1} = [4, 3, 2, 1, 0]: Prelude.Types.foldl(v2, v1, v0)
Main.{parseCommand:0} = [4, 3, 2, 1, 0]: Prelude.Types.foldr(v2, v1, v0)
Main.parseBySchema = [0, 1]: %let v5 = (Main.parsePrefix(v0, v1)) in (%case v5 of { %conalt Prelude.Types.Nothing() => %con Prelude.Types.Nothing()| %conalt Prelude.Types.Just(v2) => %case v2 of { %conalt Builtin.MkPair(v3, v4) => %case v4 of { %constalt("") => %con Prelude.Types.Just(v3) Just %con Prelude.Types.Nothing() } Just %con Prelude.Types.Nothing() } Nothing })
Main.parse = [0, 1]: %let v6 = (%let v2 = (<Main.{parse:0} underapp 1>()) in (Data.String.span(v2, v1))) in (%case v6 of { %conalt Builtin.MkPair(v3, v4) => %let v5 = (Data.String.ltrim(v4)) in (Main.parseCommand(v0, v3, v5)) Nothing })
Main.{parse:0} = [0]: %let v1 = (' ') in (Prelude.EqOrd./=(v0, v1))
Main.main = []: %let v15 = (%let v6 = (%let v3 = (%let v0 = (<Main.{main:0} underapp 5>()) in (%let v1 = (<Main.{main:1} underapp 3>()) in (%let v2 = (<Main.{main:2} underapp 5>()) in (%con Prelude.Interfaces.MkApplicative(v0, v1, v2))))) in (%let v4 = (<Main.{main:3} underapp 5>()) in (%let v5 = (<Main.{main:4} underapp 3>()) in (%con Prelude.Interfaces.MkMonad(v3, v4, v5))))) in (%let v7 = (<Main.{main:5} underapp 2>()) in (%con Prelude.IO.MkHasIO(v6, v7)))) in (%let v16 = (%let v12 = (%let v10 = (%con Main.SString()) in (%let v11 = (%let v8 = (%con Main.SString()) in (%let v9 = (%con Main.SInt()) in (%con Main..+.(v8, v9)))) in (%con Main..+.(v10, v11)))) in (%let v13 = (0) in (%let v14 = (%con Data.Vect.Nil()) in (%con Main.MkData(v12, v13, v14))))) in (%let v17 = ("Command: ") in (%let v18 = (<Main.{main:6} underapp 2>()) in (System.REPL.replWith(v15, v16, v17, v18)))))
Main.{main:6} = [1, 0]: Main.processInput(v1, v0)
Main.{main:5} = [1, 0]: v0
Main.{main:4} = [2, 1, 0]: %let v3 = (v1 @ (v0)) in (v3 @ (v0))
Main.{main:3} = [4, 3, 2, 1, 0]: %let v5 = (v2 @ (v0)) in (%let v6 = (v1 @ (v5)) in (v6 @ (v0)))
Main.{main:2} = [4, 3, 2, 1, 0]: %let v5 = (v2 @ (v0)) in (%let v6 = (v1 @ (v0)) in (v5 @ (v6)))
Main.{main:1} = [2, 1, 0]: v1
Main.{main:0} = [4, 3, 2, 1, 0]: Prelude.IO.map(v2, v1, v0)
Main.getEntry = [0, 1]: %let v22 = (%let v5 = (%case v1 of { %conalt Main.MkData(v2, v3, v4) => v3 Nothing }) in (Data.Fin.integerToFin(v0, v5))) in (%case v22 of { %conalt Prelude.Types.Nothing() => %let v7 = (%let v6 = ("Out of range\n") in (%con Builtin.MkPair(v6, v1))) in (%con Prelude.Types.Just(v7))| %conalt Prelude.Types.Just(v8) => %let v21 = (%let v20 = (%let v18 = (%let v16 = (%case v1 of { %conalt Main.MkData(v9, v10, v11) => v9 Nothing }) in (%let v17 = (%let v15 = (%case v1 of { %conalt Main.MkData(v12, v13, v14) => v14 Nothing }) in (Data.Vect.index(v8, v15))) in (Main.display(v16, v17)))) in (%let v19 = ("\n") in (%op ++(v18, v19)))) in (%con Builtin.MkPair(v20, v1))) in (%con Prelude.Types.Just(v21)) Nothing })
Main.display = [0, 1]: %case v0 of { %conalt Main.SString() => Prelude.Show.show(v1)| %conalt Main.SInt() => Prelude.Show.show(v1)| %conalt Main..+.(v2, v3) => %case v1 of { %conalt Builtin.MkPair(v4, v5) => %let v8 = (Main.display(v2, v4)) in (%let v9 = (%let v6 = (", ") in (%let v7 = (Main.display(v3, v5)) in (%op ++(v6, v7)))) in (%op ++(v8, v9))) Nothing } Nothing }
Main.addToStore = [0, 1]: %case v0 of { %conalt Main.MkData(v2, v3, v4) => %let v6 = (%let v5 = (1) in (%op +Integer(v3, v5))) in (%let v7 = (Main.4408:5086:addToData(v3, v2, v4, v1, v4)) in (%con Main.MkData(v2, v6, v7))) Nothing }
Main.SetSchema = Constructor tag Just 0 arity 1 newtype by Nothing
Main.SString = Constructor tag Just 0 arity 0 newtype by Nothing
Main.SInt = Constructor tag Just 1 arity 0 newtype by Nothing
Main.Quit = Constructor tag Just 3 arity 0 newtype by Nothing
Main.MkData = Constructor tag Just 0 arity 3 newtype by Nothing
Main.Get = Constructor tag Just 2 arity 1 newtype by Nothing
Main.Add = Constructor tag Just 1 arity 1 newtype by Nothing
Main..+. = Constructor tag Just 2 arity 2 newtype by Nothing
System.REPL.replWith = [0, 1, 2, 3]: %case v0 of { %conalt Prelude.IO.MkHasIO(v4, v5) => %case v4 of { %conalt Prelude.Interfaces.MkMonad(v6, v7, v8) => %let v13 = (%let v11 = (%let v9 = (v7 @ ([__])) in (v9 @ ([__]))) in (%let v12 = (%let v10 = (System.File.Virtual.stdin()) in (System.File.ReadWrite.fEOF(v0, v10))) in (v11 @ (v12)))) in (%let v14 = (<System.REPL.{replWith:4} underapp 1>(v0, v1, v2, v3)) in (v13 @ (v14))) Nothing } Nothing }
System.REPL.{replWith:4} = [0, 1, 2, 3, 4]: %case v4 of { %constalt(1) => %case v0 of { %conalt Prelude.IO.MkHasIO(v5, v6) => %case v5 of { %conalt Prelude.Interfaces.MkMonad(v7, v8, v9) => %case v7 of { %conalt Prelude.Interfaces.MkApplicative(v10, v11, v12) => %let v13 = (v11 @ ([__])) in (%let v14 = (%con Builtin.MkUnit()) in (v13 @ (v14))) Nothing } Nothing } Nothing }| %constalt(0) => %let v17 = (%case v0 of { %conalt Prelude.IO.MkHasIO(v15, v16) => v15 Nothing }) in (%let v18 = (Prelude.IO.putStr(v0, v2)) in (%let v19 = (<System.REPL.{replWith:3} underapp 1>(v0, v1, v2, v3)) in (Prelude.Interfaces.>>(v17, v18, v19)))) Nothing }
System.REPL.{replWith:3} = [0, 1, 2, 3, 4]: %let v8 = (%case v0 of { %conalt Prelude.IO.MkHasIO(v5, v6) => v5 Nothing }) in (%let v9 = (%let v7 = (System.File.Virtual.stdout()) in (System.File.Process.fflush(v0, v7))) in (%let v10 = (<System.REPL.{replWith:2} underapp 1>(v0, v1, v2, v3)) in (Prelude.Interfaces.>>(v8, v9, v10))))
System.REPL.{replWith:2} = [0, 1, 2, 3, 4]: %case v0 of { %conalt Prelude.IO.MkHasIO(v5, v6) => %case v5 of { %conalt Prelude.Interfaces.MkMonad(v7, v8, v9) => %let v13 = (%let v11 = (%let v10 = (v8 @ ([__])) in (v10 @ ([__]))) in (%let v12 = (Prelude.IO.getLine(v0)) in (v11 @ (v12)))) in (%let v14 = (<System.REPL.{replWith:1} underapp 1>(v0, v1, v2, v3)) in (v13 @ (v14))) Nothing } Nothing }
System.REPL.{replWith:1} = [0, 1, 2, 3, 4]: %let v24 = (%let v5 = (v3 @ (v1)) in (v5 @ (v4))) in (%case v24 of { %conalt Prelude.Types.Just(v6) => %case v6 of { %conalt Builtin.MkPair(v7, v8) => %let v11 = (%case v0 of { %conalt Prelude.IO.MkHasIO(v9, v10) => v9 Nothing }) in (%let v12 = (Prelude.IO.putStr(v0, v7)) in (%let v13 = (<System.REPL.{replWith:0} underapp 1>(v8, v0, v2, v3)) in (Prelude.Interfaces.>>(v11, v12, v13)))) Nothing }| %conalt Prelude.Types.Nothing() => %case v0 of { %conalt Prelude.IO.MkHasIO(v14, v15) => %case v14 of { %conalt Prelude.Interfaces.MkMonad(v16, v17, v18) => %case v16 of { %conalt Prelude.Interfaces.MkApplicative(v19, v20, v21) => %let v22 = (v20 @ ([__])) in (%let v23 = (%con Builtin.MkUnit()) in (v22 @ (v23))) Nothing } Nothing } Nothing } Nothing })
System.REPL.{replWith:0} = [0, 1, 2, 3, 4]: System.REPL.replWith(v1, v0, v2, v3)
System.File.Virtual.stdout = []: System.File.Virtual.prim__stdout()
System.File.Virtual.stdin = []: System.File.Virtual.prim__stdin()
System.File.Virtual.prim__stdout = Foreign call ["C:idris2_stdout, libidris2_support, idris_file.h", "node:lambda:x=>({fd:1, buffer: Buffer.alloc(0), name:'<stdout>', eof: false})"] [] -> Ptr
System.File.Virtual.prim__stdin = Foreign call ["C:idris2_stdin, libidris2_support, idris_file.h", "node:lambda:x=>({fd:0, buffer: Buffer.alloc(0), name:'<stdin>', eof: false})"] [] -> Ptr
Prelude.Basics.flip = [0, 1, 2]: %let v3 = (v0 @ (v2)) in (v3 @ (v1))
Prelude.Basics.Nil = Constructor tag Just 0 arity 0 newtype by Nothing
Prelude.Basics.Lin = Constructor tag Just 0 arity 0 newtype by Nothing
Prelude.Basics.:< = Constructor tag Just 1 arity 2 newtype by Nothing
Prelude.Basics.:: = Constructor tag Just 1 arity 2 newtype by Nothing
Builtin.believe_me = [0]: %op believe_me([__], [__], v0)
Builtin.MkUnit = Constructor tag Just 0 arity 0 newtype by Nothing
Builtin.MkPair = Constructor tag Just 0 arity 2 newtype by Nothing
Prelude.Types.null = [0]: %case v0 of { %conalt Prelude.Basics.Nil() => 1| %conalt Prelude.Basics.::(v1, v2) => 0 Nothing }
Prelude.Types.map = [0, 1]: %case v1 of { %conalt Prelude.Basics.Nil() => %con Prelude.Basics.Nil()| %conalt Prelude.Basics.::(v2, v3) => %let v4 = (v0 @ (v2)) in (%let v5 = (Prelude.Types.map(v0, v3)) in (%con Prelude.Basics.::(v4, v5))) Nothing }
Prelude.Types.foldr = [0, 1, 2]: %case v2 of { %conalt Prelude.Basics.Nil() => v1| %conalt Prelude.Basics.::(v3, v4) => %let v5 = (v0 @ (v3)) in (%let v6 = (Prelude.Types.foldr(v0, v1, v4)) in (v5 @ (v6))) Nothing }
Prelude.Types.foldl = [0, 1, 2]: %case v2 of { %conalt Prelude.Basics.Nil() => v1| %conalt Prelude.Basics.::(v3, v4) => %let v6 = (%let v5 = (v0 @ (v1)) in (v5 @ (v3))) in (Prelude.Types.foldl(v0, v6, v4)) Nothing }
Prelude.Types.foldlM = [0, 1, 2, 3]: %let v11 = (<Prelude.Types.{foldlM_Foldable_List:1} underapp 2>(v0, v1)) in (%let v12 = (%case v0 of { %conalt Prelude.Interfaces.MkMonad(v4, v5, v6) => %case v4 of { %conalt Prelude.Interfaces.MkApplicative(v7, v8, v9) => %let v10 = (v8 @ ([__])) in (v10 @ (v2)) Nothing } Nothing }) in (Prelude.Types.foldl(v11, v12, v3)))
Prelude.Types.{foldlM_Foldable_List:1} = [0, 1, 3, 2]: %case v0 of { %conalt Prelude.Interfaces.MkMonad(v4, v5, v6) => %let v9 = (%let v8 = (%let v7 = (v5 @ ([__])) in (v7 @ ([__]))) in (v8 @ (v3))) in (%let v10 = (<Prelude.Types.{foldlM_Foldable_List:0} underapp 1>(v2, v1)) in (v9 @ (v10))) Nothing }
Prelude.Types.{foldlM_Foldable_List:0} = [0, 1, 2]: Prelude.Basics.flip(v1, v0, v2)
Prelude.Types.foldMap = [0, 1, 2]: %let v5 = (<Prelude.Types.{foldMap_Foldable_List:0} underapp 2>(v0, v1)) in (%let v6 = (%case v0 of { %conalt Prelude.Interfaces.MkMonoid(v3, v4) => v4 Nothing }) in (Prelude.Types.foldl(v5, v6, v2)))
Prelude.Types.{foldMap_Foldable_List:0} = [0, 1, 3, 2]: %case v0 of { %conalt Prelude.Interfaces.MkMonoid(v4, v5) => %let v6 = (v4 @ (v3)) in (%let v7 = (v1 @ (v2)) in (v6 @ (v7))) Nothing }
Prelude.Types.prim__integerToNat = [0]: %let v3 = (%let v2 = (%let v1 = (0) in (%op <=Integer(v1, v0))) in (%case v2 of { %constalt(0) => 0 Just 1 })) in (%case v3 of { %constalt(1) => Builtin.believe_me(v0)| %constalt(0) => 0 Nothing })
Prelude.Types.isSpace = [0]: %let v13 = (%let v1 = (' ') in (Prelude.EqOrd.==(v0, v1))) in (%case v13 of { %constalt(1) => 1| %constalt(0) => %let v12 = (%let v2 = ('\t') in (Prelude.EqOrd.==(v0, v2))) in (%case v12 of { %constalt(1) => 1| %constalt(0) => %let v11 = (%let v3 = ('\r') in (Prelude.EqOrd.==(v0, v3))) in (%case v11 of { %constalt(1) => 1| %constalt(0) => %let v10 = (%let v4 = ('\n') in (Prelude.EqOrd.==(v0, v4))) in (%case v10 of { %constalt(1) => 1| %constalt(0) => %let v9 = (%let v5 = ('\f') in (Prelude.EqOrd.==(v0, v5))) in (%case v9 of { %constalt(1) => 1| %constalt(0) => %let v8 = (%let v6 = ('\v') in (Prelude.EqOrd.==(v0, v6))) in (%case v8 of { %constalt(1) => 1| %constalt(0) => %let v7 = ('\160') in (Prelude.EqOrd.==(v0, v7)) Nothing }) Nothing }) Nothing }) Nothing }) Nothing }) Nothing })
Prelude.Types.isDigit = [0]: %let v3 = (%let v1 = ('0') in (Prelude.EqOrd.>=(v0, v1))) in (%case v3 of { %constalt(1) => %let v2 = ('9') in (Prelude.EqOrd.<=(v0, v2))| %constalt(0) => 0 Nothing })
Prelude.Types.getAt = [0, 1]: %case v0 of { %constalt(0) => %case v1 of { %conalt Prelude.Basics.::(v2, v3) => %con Prelude.Types.Just(v2) Just %case v1 of { %conalt Prelude.Basics.Nil() => %con Prelude.Types.Nothing() Nothing } } Just %let v4 = (%let v5 = (1) in (%op -Integer(v0, v5))) in (%case v1 of { %conalt Prelude.Basics.::(v6, v7) => Prelude.Types.getAt(v4, v7) Just %case v1 of { %conalt Prelude.Basics.Nil() => %con Prelude.Types.Nothing() Nothing } }) }
Prelude.Types.fastUnpack = Foreign call ["scheme:string-unpack", "RefC:fastUnpack", "javascript:lambda:(str)=>__prim_js2idris_array(Array.from(str))"] [String] -> Prelude.Basics.List Char
Prelude.Types.fastPack = Foreign call ["scheme:string-pack", "RefC:fastPack", "javascript:lambda:(xs)=>__prim_idris2js_array(xs).join('')"] [Prelude.Basics.List Char] -> String
Prelude.Types.Yes = Constructor tag Just 0 arity 1 newtype by Nothing
Prelude.Types.Nothing = Constructor tag Just 0 arity 0 newtype by Nothing
Prelude.Types.No = Constructor tag Just 1 arity 1 newtype by Nothing
Prelude.Types.Just = Constructor tag Just 1 arity 1 newtype by Nothing
Prelude.Types.SnocList.<>> = [0, 1]: %case v0 of { %conalt Prelude.Basics.Lin() => v1| %conalt Prelude.Basics.:<(v2, v3) => %let v4 = (%con Prelude.Basics.::(v3, v1)) in (Prelude.Types.SnocList.<>>(v2, v4)) Nothing }
Prelude.EqOrd.compare = [0, 1]: %let v3 = (Prelude.EqOrd.<(v0, v1)) in (%case v3 of { %constalt(1) => 0| %constalt(0) => %let v2 = (Prelude.EqOrd.==(v0, v1)) in (%case v2 of { %constalt(1) => 1| %constalt(0) => 2 Nothing }) Nothing })
Prelude.EqOrd.> = [0, 1]: %let v2 = (%op >Char(v0, v1)) in (%case v2 of { %constalt(0) => 0 Just 1 })
Prelude.EqOrd.>= = [0, 1]: %let v2 = (%op >=Integer(v0, v1)) in (%case v2 of { %constalt(0) => 0 Just 1 })
Prelude.EqOrd.>= = [0, 1]: %let v2 = (%op >=Char(v0, v1)) in (%case v2 of { %constalt(0) => 0 Just 1 })
Prelude.EqOrd.== = [0, 1]: %case v0 of { %constalt(0) => %case v1 of { %constalt(0) => 1 Just 0 }| %constalt(1) => %case v1 of { %constalt(1) => 1 Just 0 }| %constalt(2) => %case v1 of { %constalt(2) => 1 Just 0 } Just 0 }
Prelude.EqOrd.== = [0, 1]: %let v2 = (%op ==Integer(v0, v1)) in (%case v2 of { %constalt(0) => 0 Just 1 })
Prelude.EqOrd.== = [0, 1]: %let v2 = (%op ==Int(v0, v1)) in (%case v2 of { %constalt(0) => 0 Just 1 })
Prelude.EqOrd.== = [0, 1]: %let v2 = (%op ==Char(v0, v1)) in (%case v2 of { %constalt(0) => 0 Just 1 })
Prelude.EqOrd.< = [0, 1]: %let v2 = (%op <Integer(v0, v1)) in (%case v2 of { %constalt(0) => 0 Just 1 })
Prelude.EqOrd.<= = [0, 1]: %let v2 = (%op <=Char(v0, v1)) in (%case v2 of { %constalt(0) => 0 Just 1 })
Prelude.EqOrd./= = [0, 1]: %let v2 = (Prelude.EqOrd.==(v0, v1)) in (%case v2 of { %constalt(1) => 0| %constalt(0) => 1 Nothing })
Prelude.EqOrd./= = [0, 1]: %let v2 = (Prelude.EqOrd.==(v0, v1)) in (%case v2 of { %constalt(1) => 0| %constalt(0) => 1 Nothing })
Prelude.EqOrd./= = [0, 1]: %let v2 = (Prelude.EqOrd.==(v0, v1)) in (%case v2 of { %constalt(1) => 0| %constalt(0) => 1 Nothing })
Prelude.Interfaces.Bool.Semigroup.<+> = [0, 1]: %case v0 of { %constalt(1) => v1| %constalt(0) => 0 Nothing }
Prelude.Interfaces.all = [0, 1, 2]: %case v0 of { %conalt Prelude.Interfaces.MkFoldable(v3, v4, v5, v6, v7, v8) => %let v15 = (%let v14 = (%let v12 = (%let v9 = (v8 @ ([__])) in (v9 @ ([__]))) in (%let v13 = (%let v10 = (<Prelude.Interfaces.{all:0} underapp 2>()) in (%let v11 = (1) in (%con Prelude.Interfaces.MkMonoid(v10, v11)))) in (v12 @ (v13)))) in (v14 @ (v1))) in (v15 @ (v2)) Nothing }
Prelude.Interfaces.{all:0} = [1, 0]: Prelude.Interfaces.Bool.Semigroup.<+>(v1, v0)
Prelude.Interfaces.MkMonoid = Constructor tag Just 0 arity 2 newtype by Nothing
Prelude.Interfaces.MkMonad = Constructor tag Just 0 arity 3 newtype by Nothing
Prelude.Interfaces.MkFoldable = Constructor tag Just 0 arity 6 newtype by Nothing
Prelude.Interfaces.MkApplicative = Constructor tag Just 0 arity 3 newtype by Nothing
Prelude.Interfaces.>> = [0, 1, 2]: %case v0 of { %conalt Prelude.Interfaces.MkMonad(v3, v4, v5) => %let v8 = (%let v7 = (%let v6 = (v4 @ ([__])) in (v6 @ ([__]))) in (v7 @ (v1))) in (%let v9 = (<Prelude.Interfaces.{>>:0} underapp 1>(v2)) in (v8 @ (v9))) Nothing }
Prelude.Interfaces.{>>:0} = [0, 1]: v0 @ ([__])
Prelude.Show.2390:10835:asciiTab = [0]: %let v63 = ("NUL") in (%let v64 = (%let v61 = ("SOH") in (%let v62 = (%let v59 = ("STX") in (%let v60 = (%let v57 = ("ETX") in (%let v58 = (%let v55 = ("EOT") in (%let v56 = (%let v53 = ("ENQ") in (%let v54 = (%let v51 = ("ACK") in (%let v52 = (%let v49 = ("BEL") in (%let v50 = (%let v47 = ("BS") in (%let v48 = (%let v45 = ("HT") in (%let v46 = (%let v43 = ("LF") in (%let v44 = (%let v41 = ("VT") in (%let v42 = (%let v39 = ("FF") in (%let v40 = (%let v37 = ("CR") in (%let v38 = (%let v35 = ("SO") in (%let v36 = (%let v33 = ("SI") in (%let v34 = (%let v31 = ("DLE") in (%let v32 = (%let v29 = ("DC1") in (%let v30 = (%let v27 = ("DC2") in (%let v28 = (%let v25 = ("DC3") in (%let v26 = (%let v23 = ("DC4") in (%let v24 = (%let v21 = ("NAK") in (%let v22 = (%let v19 = ("SYN") in (%let v20 = (%let v17 = ("ETB") in (%let v18 = (%let v15 = ("CAN") in (%let v16 = (%let v13 = ("EM") in (%let v14 = (%let v11 = ("SUB") in (%let v12 = (%let v9 = ("ESC") in (%let v10 = (%let v7 = ("FS") in (%let v8 = (%let v5 = ("GS") in (%let v6 = (%let v3 = ("RS") in (%let v4 = (%let v1 = ("US") in (%let v2 = (%con Prelude.Basics.Nil()) in (%con Prelude.Basics.::(v1, v2)))) in (%con Prelude.Basics.::(v3, v4)))) in (%con Prelude.Basics.::(v5, v6)))) in (%con Prelude.Basics.::(v7, v8)))) in (%con Prelude.Basics.::(v9, v10)))) in (%con Prelude.Basics.::(v11, v12)))) in (%con Prelude.Basics.::(v13, v14)))) in (%con Prelude.Basics.::(v15, v16)))) in (%con Prelude.Basics.::(v17, v18)))) in (%con Prelude.Basics.::(v19, v20)))) in (%con Prelude.Basics.::(v21, v22)))) in (%con Prelude.Basics.::(v23, v24)))) in (%con Prelude.Basics.::(v25, v26)))) in (%con Prelude.Basics.::(v27, v28)))) in (%con Prelude.Basics.::(v29, v30)))) in (%con Prelude.Basics.::(v31, v32)))) in (%con Prelude.Basics.::(v33, v34)))) in (%con Prelude.Basics.::(v35, v36)))) in (%con Prelude.Basics.::(v37, v38)))) in (%con Prelude.Basics.::(v39, v40)))) in (%con Prelude.Basics.::(v41, v42)))) in (%con Prelude.Basics.::(v43, v44)))) in (%con Prelude.Basics.::(v45, v46)))) in (%con Prelude.Basics.::(v47, v48)))) in (%con Prelude.Basics.::(v49, v50)))) in (%con Prelude.Basics.::(v51, v52)))) in (%con Prelude.Basics.::(v53, v54)))) in (%con Prelude.Basics.::(v55, v56)))) in (%con Prelude.Basics.::(v57, v58)))) in (%con Prelude.Basics.::(v59, v60)))) in (%con Prelude.Basics.::(v61, v62)))) in (%con Prelude.Basics.::(v63, v64)))
Prelude.Show.show = [0]: %let v3 = ('"') in (%let v4 = (%let v1 = (Prelude.Types.fastUnpack(v0)) in (%let v2 = ("\"") in (Prelude.Show.showLitString(v1, v2)))) in (%op op_strcons(v3, v4)))
Prelude.Show.show = [0]: Prelude.Show.show(v0)
Prelude.Show.show = [0]: %let v1 = (%con Prelude.Show.Open()) in (Prelude.Show.showPrec(v1, v0))
Prelude.Show.show = [0]: %let v1 = (%con Prelude.Show.Open()) in (Prelude.Show.showPrec(v1, v0))
Prelude.Show.showPrec = [0, 1]: %let v2 = (<Prelude.Show.{showPrec_Show_Integer:0} underapp 1>()) in (Prelude.Show.primNumShow(v2, v0, v1))
Prelude.Show.{showPrec_Show_Integer:0} = [0]: %op cast-Integer-String(v0)
Prelude.Show.showPrec = [0, 1]: %let v2 = (<Prelude.Show.{showPrec_Show_Int:0} underapp 1>()) in (Prelude.Show.primNumShow(v2, v0, v1))
Prelude.Show.{showPrec_Show_Int:0} = [0]: %op cast-Int-String(v0)
Prelude.Show.compare = [0, 1]: %case v0 of { %conalt Prelude.Show.User(v2) => %case v1 of { %conalt Prelude.Show.User(v3) => Prelude.EqOrd.compare(v2, v3) Just %let v4 = (Prelude.Show.precCon(v0)) in (%let v5 = (Prelude.Show.precCon(v1)) in (Prelude.EqOrd.compare(v4, v5))) } Just %let v6 = (Prelude.Show.precCon(v0)) in (%let v7 = (Prelude.Show.precCon(v1)) in (Prelude.EqOrd.compare(v6, v7))) }
Prelude.Show.>= = [0, 1]: %let v2 = (Prelude.Show.compare(v0, v1)) in (%let v3 = (0) in (Prelude.EqOrd./=(v2, v3)))
Prelude.Show.showParens = [0, 1]: %case v0 of { %constalt(0) => v1| %constalt(1) => %let v3 = ("(") in (%let v4 = (%let v2 = (")") in (%op ++(v1, v2))) in (%op ++(v3, v4))) Nothing }
Prelude.Show.showLitString = [0, 1]: %case v0 of { %conalt Prelude.Basics.Nil() => v1| %conalt Prelude.Basics.::(v2, v3) => %case v2 of { %constalt('"') => %let v4 = ("\\\"") in (%let v5 = (Prelude.Show.showLitString(v3, v1)) in (%op ++(v4, v5))) Just %let v6 = (Prelude.Show.showLitChar(v2)) in (%let v7 = (Prelude.Show.showLitString(v3, v1)) in (v6 @ (v7))) } Nothing }
Prelude.Show.showLitChar = [0]: %case v0 of { %constalt('\a') => <Prelude.Show.{showLitChar:0} underapp 1>()| %constalt('\b') => <Prelude.Show.{showLitChar:1} underapp 1>()| %constalt('\f') => <Prelude.Show.{showLitChar:2} underapp 1>()| %constalt('\n') => <Prelude.Show.{showLitChar:3} underapp 1>()| %constalt('\r') => <Prelude.Show.{showLitChar:4} underapp 1>()| %constalt('\t') => <Prelude.Show.{showLitChar:5} underapp 1>()| %constalt('\v') => <Prelude.Show.{showLitChar:6} underapp 1>()| %constalt('\SO') => <Prelude.Show.{showLitChar:8} underapp 1>()| %constalt('\DEL') => <Prelude.Show.{showLitChar:9} underapp 1>()| %constalt('\\') => <Prelude.Show.{showLitChar:10} underapp 1>() Just <Prelude.Show.{showLitChar:12} underapp 1>(v0) }
Prelude.Show.{showLitChar:12} = [0, 1]: %let v15 = (%let v3 = (%let v2 = (%op cast-Char-Integer(v0)) in (Prelude.Types.prim__integerToNat(v2))) in (%let v4 = (Prelude.Show.2390:10835:asciiTab(v0)) in (Prelude.Types.getAt(v3, v4)))) in (%case v15 of { %conalt Prelude.Types.Just(v5) => %let v6 = ('\\') in (%let v7 = (%op ++(v5, v1)) in (%op op_strcons(v6, v7)))| %conalt Prelude.Types.Nothing() => %let v14 = (%let v8 = ('\DEL') in (Prelude.EqOrd.>(v0, v8))) in (%case v14 of { %constalt(1) => %let v12 = ('\\') in (%let v13 = (%let v10 = (<Prelude.Show.{showLitChar:11} underapp 1>()) in (%let v11 = (%let v9 = (%op cast-Char-Int(v0)) in (Prelude.Show.show(v9))) in (Prelude.Show.protectEsc(v10, v11, v1)))) in (%op op_strcons(v12, v13)))| %constalt(0) => %op op_strcons(v0, v1) Nothing }) Nothing })
Prelude.Show.{showLitChar:11} = [0]: Prelude.Types.isDigit(v0)
Prelude.Show.{showLitChar:10} = [0]: %let v1 = ("\\\\") in (%op ++(v1, v0))
Prelude.Show.{showLitChar:9} = [0]: %let v1 = ("\\DEL") in (%op ++(v1, v0))
Prelude.Show.{showLitChar:8} = [0]: %let v1 = (<Prelude.Show.{showLitChar:7} underapp 1>()) in (%let v2 = ("\\SO") in (Prelude.Show.protectEsc(v1, v2, v0)))
Prelude.Show.{showLitChar:7} = [0]: %let v1 = ('H') in (Prelude.EqOrd.==(v0, v1))
Prelude.Show.{showLitChar:6} = [0]: %let v1 = ("\\v") in (%op ++(v1, v0))
Prelude.Show.{showLitChar:5} = [0]: %let v1 = ("\\t") in (%op ++(v1, v0))
Prelude.Show.{showLitChar:4} = [0]: %let v1 = ("\\r") in (%op ++(v1, v0))
Prelude.Show.{showLitChar:3} = [0]: %let v1 = ("\\n") in (%op ++(v1, v0))
Prelude.Show.{showLitChar:2} = [0]: %let v1 = ("\\f") in (%op ++(v1, v0))
Prelude.Show.{showLitChar:1} = [0]: %let v1 = ("\\b") in (%op ++(v1, v0))
Prelude.Show.{showLitChar:0} = [0]: %let v1 = ("\\a") in (%op ++(v1, v0))
Prelude.Show.protectEsc = [0, 1, 2]: %let v5 = (%let v4 = (%let v3 = (Prelude.Show.firstCharIs(v0, v2)) in (%case v3 of { %constalt(1) => "\\&"| %constalt(0) => "" Nothing })) in (%op ++(v4, v2))) in (%op ++(v1, v5))
Prelude.Show.primNumShow = [0, 1, 2]: %let v3 = (v0 @ (v2)) in (%let v7 = (%let v6 = (%let v4 = (%con Prelude.Show.PrefixMinus()) in (Prelude.Show.>=(v1, v4))) in (%case v6 of { %constalt(1) => %let v5 = (<Prelude.Show.{primNumShow:0} underapp 1>()) in (Prelude.Show.firstCharIs(v5, v3))| %constalt(0) => 0 Nothing })) in (Prelude.Show.showParens(v7, v3)))
Prelude.Show.{primNumShow:0} = [0]: %let v1 = ('-') in (Prelude.EqOrd.==(v0, v1))
Prelude.Show.precCon = [0]: %case v0 of { %conalt Prelude.Show.Open() => 0| %conalt Prelude.Show.Equal() => 1| %conalt Prelude.Show.Dollar() => 2| %conalt Prelude.Show.Backtick() => 3| %conalt Prelude.Show.User(v1) => 4| %conalt Prelude.Show.PrefixMinus() => 5| %conalt Prelude.Show.App() => 6 Nothing }
Prelude.Show.firstCharIs = [0, 1]: %case v1 of { %constalt("") => 0 Just %let v2 = (%op op_strhead(v1)) in (v0 @ (v2)) }
Prelude.Show.PrefixMinus = Constructor tag Just 5 arity 0 newtype by Nothing
Prelude.Show.Open = Constructor tag Just 0 arity 0 newtype by Nothing
Prelude.IO.map = [0, 1, 2]: %let v3 = (v1 @ (v2)) in (v0 @ (v3))
Prelude.IO.putStr = [0, 1]: %case v0 of { %conalt Prelude.IO.MkHasIO(v2, v3) => %let v4 = (v3 @ ([__])) in (%let v5 = (<Prelude.IO.{putStr:0} underapp 1>(v1)) in (v4 @ (v5))) Nothing }
Prelude.IO.{putStr:0} = [0, 1]: Prelude.IO.prim__putStr(v0, v1)
Prelude.IO.prim__putStr = Foreign call ["C:idris2_putStr, libidris2_support, idris_support.h", "node:lambda:x=>process.stdout.write(x)", "browser:lambda:x=>console.log(x)"] [String, %World] -> IORes Unit
Prelude.IO.prim__getStr = Foreign call ["C:idris2_getStr, libidris2_support, idris_support.h", "node:support:getStr,support_system_file"] [%World] -> IORes String
Prelude.IO.getLine = [0]: %case v0 of { %conalt Prelude.IO.MkHasIO(v1, v2) => %let v3 = (v2 @ ([__])) in (%let v4 = (<Prelude.IO.{getLine:0} underapp 1>()) in (v3 @ (v4))) Nothing }
Prelude.IO.{getLine:0} = [0]: Prelude.IO.prim__getStr(v0)
Prelude.IO.MkHasIO = Constructor tag Just 0 arity 2 newtype by Nothing
PrimIO.unsafePerformIO = [0]: %let v1 = (<PrimIO.{unsafePerformIO:0} underapp 1>(v0)) in (PrimIO.unsafeCreateWorld(v1))
PrimIO.{unsafePerformIO:0} = [0, 1]: v0 @ (v1)
PrimIO.unsafeCreateWorld = [0]: %let v1 = (%MkWorld) in (v0 @ (v1))
Prelude.Cast.cast = [0]: %op cast-String-Integer(v0)
Prelude.Cast.cast = [0]: %op cast-String-Int(v0)
System.File.ReadWrite.prim__eof = Foreign call ["C:idris2_eof, libidris2_support, idris_file.h", "node:lambda:x=>(x.eof?1:0)"] [Ptr, %World] -> IORes Int
System.File.ReadWrite.fEOF = [0, 1]: %case v0 of { %conalt Prelude.IO.MkHasIO(v2, v3) => %case v2 of { %conalt Prelude.Interfaces.MkMonad(v4, v5, v6) => %let v14 = (%let v12 = (%let v7 = (v5 @ ([__])) in (v7 @ ([__]))) in (%let v13 = (%case v0 of { %conalt Prelude.IO.MkHasIO(v8, v9) => %let v10 = (v9 @ ([__])) in (%let v11 = (<System.File.ReadWrite.{fEOF:0} underapp 1>(v1)) in (v10 @ (v11))) Nothing }) in (v12 @ (v13)))) in (%let v15 = (<System.File.ReadWrite.{fEOF:1} underapp 1>(v0)) in (v14 @ (v15))) Nothing } Nothing }
System.File.ReadWrite.{fEOF:1} = [0, 1]: %case v0 of { %conalt Prelude.IO.MkHasIO(v2, v3) => %case v2 of { %conalt Prelude.Interfaces.MkMonad(v4, v5, v6) => %case v4 of { %conalt Prelude.Interfaces.MkApplicative(v7, v8, v9) => %let v12 = (v8 @ ([__])) in (%let v13 = (%let v11 = (%let v10 = (0) in (%op cast-Integer-Int(v10))) in (Prelude.EqOrd./=(v1, v11))) in (v12 @ (v13))) Nothing } Nothing } Nothing }
System.File.ReadWrite.{fEOF:0} = [0, 1]: System.File.ReadWrite.prim__eof(v0, v1)
Data.Fin.natToFin = [0, 1]: %let v4 = (Data.Nat.isLT(v0, v1)) in (%case v4 of { %conalt Prelude.Types.Yes(v2) => %con Prelude.Types.Just(v0)| %conalt Prelude.Types.No(v3) => %con Prelude.Types.Nothing() Nothing })
Data.Fin.integerToFin = [0, 1]: %case v1 of { %constalt(0) => %con Prelude.Types.Nothing() Just %let v4 = (%let v2 = (0) in (Prelude.EqOrd.>=(v0, v2))) in (%case v4 of { %constalt(1) => %let v3 = (Prelude.Types.prim__integerToNat(v0)) in (Data.Fin.natToFin(v3, v1))| %constalt(0) => %con Prelude.Types.Nothing() Nothing }) }
Data.Nat.succNotLTEzero = [0]: %CRASH("No clauses")
Data.Nat.isLTE = [0, 1]: %case v0 of { %constalt(0) => %let v2 = (0) in (%con Prelude.Types.Yes(v2)) Just %let v3 = (%let v4 = (1) in (%op -Integer(v0, v4))) in (%case v1 of { %constalt(0) => %let v5 = (<Data.Nat.{isLTE:0} underapp 1>()) in (%con Prelude.Types.No(v5)) Just %let v6 = (%let v7 = (1) in (%op -Integer(v1, v7))) in (%let v13 = (Data.Nat.isLTE(v3, v6)) in (%case v13 of { %conalt Prelude.Types.No(v8) => %let v9 = (<Data.Nat.{isLTE:1} underapp 1>(v8)) in (%con Prelude.Types.No(v9))| %conalt Prelude.Types.Yes(v10) => %let v12 = (%let v11 = (1) in (%op +Integer(v10, v11))) in (%con Prelude.Types.Yes(v12)) Nothing })) }) }
Data.Nat.{isLTE:1} = [0, 1]: %let v2 = (Data.Nat.fromLteSucc(v1)) in (v0 @ (v2))
Data.Nat.{isLTE:0} = [0]: Data.Nat.succNotLTEzero(v0)
Data.Nat.isLT = [0, 1]: %let v3 = (%let v2 = (1) in (%op +Integer(v0, v2))) in (Data.Nat.isLTE(v3, v1))
Data.Nat.fromLteSucc = [0]: %case v0 of { %constalt(0) => %CRASH("Nat case not covered") Just %let v1 = (%let v2 = (1) in (%op -Integer(v0, v2))) in (v1) }
Data.List.span = [0, 1]: %case v1 of { %conalt Prelude.Basics.Nil() => %let v2 = (%con Prelude.Basics.Nil()) in (%let v3 = (%con Prelude.Basics.Nil()) in (%con Builtin.MkPair(v2, v3)))| %conalt Prelude.Basics.::(v4, v5) => %let v12 = (v0 @ (v4)) in (%case v12 of { %constalt(1) => %let v9 = (Data.List.span(v0, v5)) in (%case v9 of { %conalt Builtin.MkPair(v6, v7) => %let v8 = (%con Prelude.Basics.::(v4, v6)) in (%con Builtin.MkPair(v8, v7)) Nothing })| %constalt(0) => %let v10 = (%con Prelude.Basics.Nil()) in (%let v11 = (%con Prelude.Basics.::(v4, v5)) in (%con Builtin.MkPair(v10, v11))) Nothing }) Nothing }
System.File.Process.prim__flush = Foreign call ["C:fflush,libc 6"] [Ptr, %World] -> IORes Int
System.File.Process.fflush = [0, 1]: %case v0 of { %conalt Prelude.IO.MkHasIO(v2, v3) => %case v2 of { %conalt Prelude.Interfaces.MkMonad(v4, v5, v6) => %case v4 of { %conalt Prelude.Interfaces.MkApplicative(v7, v8, v9) => %let v17 = (%let v11 = (%let v10 = (v7 @ ([__])) in (v10 @ ([__]))) in (%let v12 = (<System.File.Process.{fflush:0} underapp 1>()) in (v11 @ (v12)))) in (%let v18 = (%case v0 of { %conalt Prelude.IO.MkHasIO(v13, v14) => %let v15 = (v14 @ ([__])) in (%let v16 = (<System.File.Process.{fflush:1} underapp 1>(v1)) in (v15 @ (v16))) Nothing }) in (v17 @ (v18))) Nothing } Nothing } Nothing }
System.File.Process.{fflush:1} = [0, 1]: System.File.Process.prim__flush(v0, v1)
System.File.Process.{fflush:0} = [0]: %con Builtin.MkUnit()
Data.Vect.index = [0, 1]: %case v0 of { %constalt(0) => %case v1 of { %conalt Data.Vect.::(v2, v3) => v2 Nothing } Just %let v4 = (%let v5 = (1) in (%op -Integer(v0, v5))) in (%case v1 of { %conalt Data.Vect.::(v6, v7) => Data.Vect.index(v4, v7) Nothing }) }
Data.Vect.Nil = Constructor tag Just 0 arity 0 newtype by Nothing
Data.Vect.:: = Constructor tag Just 1 arity 2 newtype by Nothing
Data.String.with block in ltrim = [0, 1]: %case v0 of { %constalt("") => %case v1 of { %conalt Data.String.Nil() => "" Just %case v1 of { %conalt Data.String.::(v2, v3, v4) => %let v5 = (%op op_strcons(v2, v3)) in (%let v7 = (Prelude.Types.isSpace(v2)) in (%case v7 of { %constalt(1) => %let v6 = (v4 @ ([__])) in (Data.String.with block in ltrim(v3, v6))| %constalt(0) => v5 Nothing })) Nothing } } Just %case v1 of { %conalt Data.String.::(v8, v9, v10) => %let v11 = (%op op_strcons(v8, v9)) in (%let v13 = (Prelude.Types.isSpace(v8)) in (%case v13 of { %constalt(1) => %let v12 = (v10 @ ([__])) in (Data.String.with block in ltrim(v9, v12))| %constalt(0) => v11 Nothing })) Nothing } }
Data.String.with block in asList = [0, 1]: %case v0 of { %constalt("") => %case v1 of { %conalt Data.String.StrNil() => %con Data.String.Nil() Just %case v1 of { %conalt Data.String.StrCons(v2, v3) => %let v4 = (<Data.String.{with block in asList (6479):0} underapp 1>(v3)) in (%con Data.String.::(v2, v3, v4)) Nothing } } Just %case v1 of { %conalt Data.String.StrCons(v5, v6) => %let v7 = (<Data.String.{with block in asList (6479):1} underapp 1>(v6)) in (%con Data.String.::(v5, v6, v7)) Nothing } }
Data.String.{with block in asList (6479):1} = [0, 1]: Data.String.asList(v0)
Data.String.{with block in asList (6479):0} = [0, 1]: Data.String.asList(v0)
Data.String.3643:6241:wordsHelper = [0, 1, 2]: %case v1 of { %conalt Prelude.Basics.Lin() => v2 Just %let v4 = (%let v3 = (%con Prelude.Basics.Nil()) in (Prelude.Types.SnocList.<>>(v1, v3))) in (%con Prelude.Basics.:<(v2, v4)) }
Data.String.3643:6242:words' = [0, 1, 2, 3]: %case v1 of { %conalt Prelude.Basics.::(v4, v5) => %let v9 = (Prelude.Types.isSpace(v4)) in (%case v9 of { %constalt(1) => %let v6 = (%con Prelude.Basics.Lin()) in (%let v7 = (Data.String.3643:6241:wordsHelper(v0, v2, v3)) in (Data.String.3643:6242:words'(v0, v5, v6, v7)))| %constalt(0) => %let v8 = (%con Prelude.Basics.:<(v2, v4)) in (Data.String.3643:6242:words'(v0, v5, v8, v3)) Nothing })| %conalt Prelude.Basics.Nil() => %let v10 = (Data.String.3643:6241:wordsHelper(v0, v2, v3)) in (%let v11 = (%con Prelude.Basics.Nil()) in (Prelude.Types.SnocList.<>>(v10, v11))) Nothing }
Data.String.words = [0]: %let v4 = (<Data.String.{words:0} underapp 1>()) in (%let v5 = (%let v1 = (Prelude.Types.fastUnpack(v0)) in (%let v2 = (%con Prelude.Basics.Lin()) in (%let v3 = (%con Prelude.Basics.Lin()) in (Data.String.3643:6242:words'(v0, v1, v2, v3))))) in (Prelude.Types.map(v4, v5)))
Data.String.{words:0} = [0]: Prelude.Types.fastPack(v0)
Data.String.strM = [0]: %case v0 of { %constalt("") => %con Data.String.StrNil() Just %let v3 = (%let v1 = (%op op_strhead(v0)) in (%let v2 = (%op op_strtail(v0)) in (%con Data.String.StrCons(v1, v2)))) in (Builtin.believe_me(v3)) }
Data.String.span = [0, 1]: %let v7 = (%let v2 = (Prelude.Types.fastUnpack(v1)) in (Data.List.span(v0, v2))) in (%case v7 of { %conalt Builtin.MkPair(v3, v4) => %let v5 = (Prelude.Types.fastPack(v3)) in (%let v6 = (Prelude.Types.fastPack(v4)) in (%con Builtin.MkPair(v5, v6))) Nothing })
Data.String.ltrim = [0]: %let v1 = (Data.String.asList(v0)) in (Data.String.with block in ltrim(v0, v1))
Data.String.asList = [0]: %let v1 = (Data.String.strM(v0)) in (Data.String.with block in asList(v0, v1))
Data.String.StrNil = Constructor tag Just 0 arity 0 newtype by Nothing
Data.String.StrCons = Constructor tag Just 1 arity 2 newtype by Nothing
Data.String.Nil = Constructor tag Just 0 arity 0 newtype by Nothing
Data.String.:: = Constructor tag Just 1 arity 3 newtype by Nothing
